from geopy.geocoders import Nominatim
import requests
import csv 
import time
import statistics
import numpy as np

# This script queries solar irradiation data (global, direct, diffuse) for a grid over Sweden.
# It returns results as a CSV file containing coordinates, place names, average values, and clarity ratio.

#Fetches irradition data (global, direct, diffuse) from SHMI's STRÃ…NG API 
#Returns a list of avg values for given coordinate and date range
def get_irradiation (lat, lon, data_type, date_from, date_to):

    vaild_data_types= { #check that data_type is vaild. 
        "global" : 117,
        "direct" : 118,
        "diffuse" : 119
    }

    if data_type not in vaild_data_types:
        return [] 
    
    data_type_code = vaild_data_types[data_type]

    url = ((
        f"https://opendata-download-metanalys.smhi.se/api/category/strang1g/version/1/"
        f"geotype/point/lon/{lon:.2f}/lat/{lat:.2f}/parameter/{data_type_code}/data.txt?"
        f"from={date_from}&to={date_to}&interval=daily")
    )
    try: 
        response = requests.get(url)
        raw_data = response.text.splitlines()

        irradiation_values = [] # This will store all the values generated by the request.
    
        for line in raw_data:
            if "-999" not in line: # -999, value missing (so i remove them).
                parts = line.strip().split()
                if len(parts) == 5: 
                    value = float(parts[-1]) #last value is the irradiation.
                    irradiation_values.append(value)

        return irradiation_values
    except: 
        return []


# Uses reverse goecoding to get place name from coordinates
def get_location_name(lat,lon):
    geolocator = Nominatim(user_agent="solar_mapper")
    try: 
        location = geolocator.reverse((lat,lon), exactly_one=True, timeout=10)
        address = location.raw.get("address", {})
        return address.get("municipality") or address.get("town") or address.get("city") or "Unknown"
    
    except: 
        return "Unknown"

# Main function to iterate over a grid across Sweden aand collects irraditation data
# resolution_deg defines how fine-grained the grid is (e.g. which zoom-level on the map you are)
def collect_data_for_sweden(date_from, date_to, resolution_deg=1.0):
    lat_range = np.arange(55.0, 69.1, resolution_deg)
    lon_range = np.arange(11.0, 25.1, resolution_deg)

    with open("soldata_svergie.csv", "w", newline="") as file: 
        writer = csv.writer(file)
        writer.writerow(["location", "lat", "lon", "global_avg", "direct_avg", "diffuse_avg", "clarity_ratio"])

        for lat in lat_range:
            for lon in lon_range:

                # Fetch all three types of irradiation data
                global_values = get_irradiation(lat, lon, "global", date_from, date_to)
                direct_values = get_irradiation(lat, lon, "direct", date_from, date_to)
                diffuse_values = get_irradiation(lat, lon, "diffuse", date_from, date_to)

                # Proceed if data is complete and valid
                if global_values and direct_values and len(global_values) == len(direct_values):
                    global_avg = sum(global_values) /len(global_values)
                    direct_avg = sum(direct_values) / len(direct_values)
                    diffuse_avg = sum(diffuse_values) / len(diffuse_values) if diffuse_values else 0
                    clarity = direct_avg / global_avg if global_avg else 0

                    # Write data to CSV file
                    writer.writerow([
                        round(lat,2),
                        round(lon,2),
                        round(global_avg, 2),
                        round(direct_avg, 2),
                        round(diffuse_avg, 2),
                        round(clarity, 2)
                    ])
                
                # Print ou
                print(f"({lat:.2f}, {lon:.2f} - Global: {global_avg:.1f}, Clarity: {clarity:.2f}")
            else:
                print(f"Skipped ({lat:.2f}, {lon:.2f}) - Incomplete data")

            time.sleep(1.1) # No to exceed nominatim API rate limit (max 1 req/sec)


if __name__ == "__main__":
    collect_data_for_sweden(20240601,20240607, resolution_deg=0.25)